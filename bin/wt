#!/usr/bin/env bash
set -euo pipefail

WT_ROOT="${WT_ROOT:-$HOME/.wt}"
CONFIG_FILE="$WT_ROOT/config"

if [ -f "$CONFIG_FILE" ]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
fi

WORKSPACE_DIR="${WORKSPACE_DIR:-$HOME/workspace}"
GITHUB_HOST="${GITHUB_HOST:-github.com}"
GIT_PROTOCOL="${GIT_PROTOCOL:-ssh}"
DEFAULT_AGENT="${DEFAULT_AGENT:-codex}"
DEFAULT_GITHUB_OWNER="${DEFAULT_GITHUB_OWNER:-}"
REPOSITORY_LIST="${REPOSITORY_LIST:-}"
WT_TEMPLATE_DIR="${WT_TEMPLATE_DIR:-$WT_ROOT/templates}"
LAST_WORKTREE_PATH=""

print_help() {
    cat <<'HELP'
wt - Worktree automation CLI (macOS + GitHub)

Usage:
  wt init [owner/repo|owner]
  wt repo [owner] [--init]
  wt branch [repo|owner/repo] [new-branch] [base-branch]
  wt status [repo]
  wt prune [repo]
  wt agent [codex|gemini|claude|shell] [worktree-path]
  wt list
  wt auth-check
  wt help

Notes:
  - Agent order starts with codex by design.
  - `wt init` continues to branch creation and agent launch.
  - Worktrees are created under: <workspace>/<repo>/<branch>
HELP
}

check_deps() {
    local deps=("$@")
    local dep
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            echo "Error: '$dep' is required."
            exit 1
        fi
    done
}

ensure_workspace() {
    mkdir -p "$WORKSPACE_DIR"
}

repo_name_from_input() {
    local input="$1"
    if [[ "$input" == */* ]]; then
        echo "${input##*/}"
        return 0
    fi
    echo "$input"
}

bare_dir_for_name() {
    local repo_name="$1"
    echo "$WORKSPACE_DIR/$repo_name/.bare"
}

worktree_root_for_name() {
    local repo_name="$1"
    echo "$WORKSPACE_DIR/$repo_name"
}

require_initialized_repo() {
    local repo_name="$1"
    local bare_dir
    bare_dir="$(bare_dir_for_name "$repo_name")"
    if [ ! -d "$bare_dir" ]; then
        echo "Error: Repository '$repo_name' is not initialized."
        echo "Run: wt init <owner/repo>"
        exit 1
    fi
}

list_initialized_repo_names() {
    ensure_workspace
    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            basename "$repo_dir"
        fi
    done
}

pick_initialized_repo() {
    local selected
    selected="$(list_initialized_repo_names | fzf --prompt="Repo> " --height=30% --layout=reverse || true)"
    if [ -z "$selected" ]; then
        echo "No repository selected."
        exit 0
    fi
    echo "$selected"
}

require_gh_auth() {
    if gh auth status -h "$GITHUB_HOST" >/dev/null 2>&1; then
        return 0
    fi
    echo "GitHub auth is not configured for host: $GITHUB_HOST"
    echo "Run: gh auth login -h $GITHUB_HOST"
    exit 1
}

default_owner() {
    if [ -n "$DEFAULT_GITHUB_OWNER" ]; then
        echo "$DEFAULT_GITHUB_OWNER"
        return 0
    fi

    local owner
    owner="$(gh api user --jq '.login' 2>/dev/null || true)"
    if [ -n "$owner" ]; then
        echo "$owner"
        return 0
    fi

    echo "Error: Could not detect default GitHub owner." >&2
    echo "Set DEFAULT_GITHUB_OWNER in $CONFIG_FILE or pass owner explicitly." >&2
    exit 1
}

configured_repo_candidates() {
    if [ -z "$REPOSITORY_LIST" ]; then
        return 1
    fi

    local parsed
    parsed="$({
        echo "$REPOSITORY_LIST" | tr ',;' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
    } | awk 'NF && $0 ~ /.+\/.+/ && !seen[$0]++')"

    if [ -z "$parsed" ]; then
        return 1
    fi
    echo "$parsed"
}

cmd_auth_check() {
    if gh auth status -h "$GITHUB_HOST" >/dev/null 2>&1; then
        echo "GitHub auth is ready for host: $GITHUB_HOST"
        return 0
    fi

    echo "GitHub auth is not configured for host: $GITHUB_HOST"
    echo "Run: gh auth login -h $GITHUB_HOST"
    return 1
}

fetch_repo_metadata_json() {
    local repo_full="$1"
    gh repo view "$repo_full" --json nameWithOwner,sshUrl,url,isPrivate 2>/dev/null || true
}

set_repo_metadata_from_json() {
    local repo_json="$1"
    REPO_NAME_WITH_OWNER="$(echo "$repo_json" | jq -r '.nameWithOwner')"
    REPO_NAME="$(echo "$repo_json" | jq -r '.nameWithOwner | split("/") | .[1]')"
    REPO_SSH_URL="$(echo "$repo_json" | jq -r '.sshUrl')"
    REPO_HTTP_URL="$(echo "$repo_json" | jq -r '.url')"
    REPO_VISIBILITY="$(echo "$repo_json" | jq -r 'if .isPrivate then "private" else "public" end')"
}

fetch_repo_metadata() {
    local repo_full="$1"
    local repo_json
    repo_json="$(fetch_repo_metadata_json "$repo_full")"
    if [ -z "$repo_json" ] || [ "$repo_json" = "null" ]; then
        echo "Error: Repository not found or access denied: $repo_full"
        exit 1
    fi
    set_repo_metadata_from_json "$repo_json"
}

set_repo_metadata_from_tsv_row() {
    local repo_row="$1"
    REPO_NAME_WITH_OWNER="$(echo "$repo_row" | awk -F'\t' '{print $1}')"
    REPO_NAME="${REPO_NAME_WITH_OWNER##*/}"
    REPO_SSH_URL="$(echo "$repo_row" | awk -F'\t' '{print $2}')"
    REPO_HTTP_URL="$(echo "$repo_row" | awk -F'\t' '{print $3}')"
    if [ "$(echo "$repo_row" | awk -F'\t' '{print $4}')" = "true" ]; then
        REPO_VISIBILITY="private"
    else
        REPO_VISIBILITY="public"
    fi
}

select_repo_from_project_file() {
    local project_file="$1"
    local display_file selected_line selected_repo repo_row
    display_file="$(mktemp)"

    while IFS=$'\t' read -r name_with_owner _ssh _https is_private; do
        local repo_name state vis
        repo_name="${name_with_owner##*/}"
        vis="public"
        if [ "$is_private" = "true" ]; then
            vis="private"
        fi

        if [ -d "$WORKSPACE_DIR/$repo_name/.bare" ]; then
            state="[Initialized]"
        else
            state="[New]"
        fi

        echo "$state $name_with_owner ($vis)" >> "$display_file"
    done < "$project_file"

    selected_line="$(fzf --prompt="Repo> " --height=40% --layout=reverse < "$display_file" || true)"
    rm -f "$display_file"

    if [ -z "$selected_line" ]; then
        echo "No repository selected."
        exit 0
    fi

    selected_repo="$(echo "$selected_line" | awk '{print $2}')"
    repo_row="$(awk -F'\t' -v repo="$selected_repo" '$1 == repo { print; exit }' "$project_file")"

    if [ -z "$repo_row" ]; then
        echo "Error: Failed to resolve repository metadata for selection."
        exit 1
    fi

    set_repo_metadata_from_tsv_row "$repo_row"
}

select_repo_from_owner() {
    local owner="$1"
    local repos_json project_file

    repos_json="$(gh repo list "$owner" --limit 200 --json nameWithOwner,sshUrl,url,isPrivate 2>/dev/null || true)"
    if [ -z "$repos_json" ] || [ "$repos_json" = "[]" ]; then
        echo "Error: No repositories found for owner '$owner' or access denied."
        exit 1
    fi

    project_file="$(mktemp)"
    echo "$repos_json" | jq -r '.[] | "\(.nameWithOwner)\t\(.sshUrl)\t\(.url)\t\(.isPrivate)"' > "$project_file"
    select_repo_from_project_file "$project_file"
    rm -f "$project_file"
}

select_repo_from_config() {
    local project_file repo_candidate repo_json
    project_file="$(mktemp)"

    while IFS= read -r repo_candidate; do
        repo_json="$(fetch_repo_metadata_json "$repo_candidate")"
        if [ -z "$repo_json" ] || [ "$repo_json" = "null" ]; then
            echo "Warning: configured repository not accessible: $repo_candidate"
            continue
        fi
        echo "$repo_json" | jq -r '"\(.nameWithOwner)\t\(.sshUrl)\t\(.url)\t\(.isPrivate)"' >> "$project_file"
    done < <(configured_repo_candidates || true)

    if [ ! -s "$project_file" ]; then
        rm -f "$project_file"
        echo "Error: No accessible repositories found in REPOSITORY_LIST."
        echo "Set REPOSITORY_LIST in $CONFIG_FILE as comma-separated owner/repo values."
        exit 1
    fi

    select_repo_from_project_file "$project_file"
    rm -f "$project_file"
}

repo_clone_url() {
    if [ "$GIT_PROTOCOL" = "ssh" ]; then
        echo "$REPO_SSH_URL"
        return 0
    fi
    echo "$REPO_HTTP_URL"
}

init_repo() {
    local repo_dir bare_dir clone_url
    repo_dir="$WORKSPACE_DIR/$REPO_NAME"
    bare_dir="$repo_dir/.bare"

    if [ -d "$bare_dir" ]; then
        echo "Already initialized: $REPO_NAME_WITH_OWNER"
        echo " - Bare repo: $bare_dir"
        echo " - Worktree location: $repo_dir/<branch>"
        return 0
    fi

    if [ -d "$repo_dir/.git" ]; then
        echo "Error: Standard repo exists at $repo_dir"
        echo "Phase 3 convert support is not included yet. Move/rename it first."
        exit 1
    fi

    if [ -e "$repo_dir" ] && [ ! -d "$repo_dir" ]; then
        echo "Error: Path exists and is not a directory: $repo_dir"
        exit 1
    fi

    clone_url="$(repo_clone_url)"
    mkdir -p "$repo_dir"
    git clone --bare "$clone_url" "$bare_dir"
    git -C "$bare_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

    echo "Initialized repository:"
    echo " - Repo: $REPO_NAME_WITH_OWNER ($REPO_VISIBILITY)"
    echo " - Bare repo: $bare_dir"
    echo " - Worktree location: $repo_dir/<branch>"
}

choose_base_branch() {
    local bare_dir="$1"
    local selected
    selected="$({
        git -C "$bare_dir" for-each-ref --format='%(refname:short)' refs/heads
        git -C "$bare_dir" for-each-ref --format='%(refname:short)' refs/remotes/origin | sed '/^origin\/HEAD$/d;s#^origin/##'
    } | awk 'NF && !seen[$0]++' | sort -u | grep -v '^origin$' | fzf --prompt="Base> " --height=30% --layout=reverse)" || true

    if [ -z "$selected" ]; then
        echo "No base branch selected."
        exit 1
    fi
    echo "$selected"
}

resolve_base_ref() {
    local bare_dir="$1"
    local base_branch="$2"
    if [ "$base_branch" = "origin" ]; then
        return 1
    fi
    if git -C "$bare_dir" show-ref --verify --quiet "refs/heads/$base_branch"; then
        echo "$base_branch"
        return 0
    fi
    if git -C "$bare_dir" show-ref --verify --quiet "refs/remotes/origin/$base_branch"; then
        echo "origin/$base_branch"
        return 0
    fi
    return 1
}

resolve_branch_worktree_path() {
    local repo_name="$1"
    local branch_name="$2"
    local root path suffix dir_name
    root="$(worktree_root_for_name "$repo_name")"
    mkdir -p "$root"

    # Convert unsafe path characters to '-', then normalize dashes.
    # Keep only alnum, dot, underscore, dash.
    dir_name="$(echo "$branch_name" \
        | sed 's/[^[:alnum:]._-]/-/g' \
        | sed 's/-\\{2,\\}/-/g' \
        | sed 's/^-*//;s/-*$//')"
    if [ -z "$dir_name" ]; then
        dir_name="branch"
    fi

    path="$root/$dir_name"
    if [ ! -e "$path" ]; then
        echo "$path"
        return 0
    fi
    suffix="$(date +%s)"
    echo "${path}_${suffix}"
}

seed_worktree_file() {
    local worktree_path="$1"
    local file_name="$2"
    local src="$WT_TEMPLATE_DIR/$file_name"
    local dst="$worktree_path/$file_name"
    if [ -f "$src" ] && [ ! -f "$dst" ]; then
        cp "$src" "$dst"
    fi
}

set_repo_toml_project_name() {
    local repo_toml="$1"
    local repo_name="$2"
    local tmp_file

    if [ ! -f "$repo_toml" ] || [ -z "$repo_name" ]; then
        return 0
    fi

    tmp_file="$(mktemp)"
    awk -v repo="$repo_name" '
        BEGIN { name_replaced = 0 }
        {
            gsub(/__REPO_NAME__/, repo)
            if (!name_replaced && $0 ~ /^name[[:space:]]*=/) {
                print "name = \"" repo "\""
                name_replaced = 1
                next
            }
            print
        }
    ' "$repo_toml" > "$tmp_file"
    mv "$tmp_file" "$repo_toml"
}

infer_repo_name_from_worktree() {
    local worktree_path="$1"
    local wt_abs ws_abs rel

    if [ ! -d "$worktree_path" ]; then
        return 1
    fi

    wt_abs="$(cd "$worktree_path" && pwd -P)"
    ws_abs="$(cd "$WORKSPACE_DIR" && pwd -P 2>/dev/null || true)"

    if [ -z "$ws_abs" ]; then
        return 1
    fi

    case "$wt_abs" in
        "$ws_abs"/*)
            rel="${wt_abs#$ws_abs/}"
            echo "${rel%%/*}"
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

prepare_worktree_context() {
    local worktree_path="$1"
    local repo_name="${2:-}"

    mkdir -p "$worktree_path"
    seed_worktree_file "$worktree_path" "repo.toml"
    seed_worktree_file "$worktree_path" "mcp-usage-guidelines.md"

    if [ -z "$repo_name" ]; then
        repo_name="$(infer_repo_name_from_worktree "$worktree_path" || true)"
    fi

    set_repo_toml_project_name "$worktree_path/repo.toml" "$repo_name"
}

build_initial_prompt() {
    local worktree_path="$1"

    cat <<PROMPT
Project bootstrap context:
1) Read ./repo.toml for repository-specific defaults.
2) Read ./mcp-usage-guidelines.md and follow those MCP usage rules.
3) Then continue work in this branch worktree: $worktree_path
PROMPT
}

cmd_branch() {
    check_deps git
    ensure_workspace

    local repo_arg="${1:-}"
    local new_branch="${2:-}"
    local base_branch="${3:-}"
    local repo_name bare_dir target_path base_ref

    if [ -z "$repo_arg" ] || [ -z "$base_branch" ]; then
        check_deps fzf
    fi

    if [ -z "$repo_arg" ]; then
        repo_name="$(pick_initialized_repo)"
    else
        repo_name="$(repo_name_from_input "$repo_arg")"
    fi

    require_initialized_repo "$repo_name"
    bare_dir="$(bare_dir_for_name "$repo_name")"

    git -C "$bare_dir" fetch --all --prune >/dev/null 2>&1 || true

    if [ -z "$base_branch" ]; then
        base_branch="$(choose_base_branch "$bare_dir")"
    fi

    if [ -z "$new_branch" ]; then
        read -r -p "New branch name: " new_branch
    fi
    if [ -z "$new_branch" ]; then
        echo "Error: new branch name is required."
        exit 1
    fi

    base_ref="$(resolve_base_ref "$bare_dir" "$base_branch" || true)"
    if [ -z "$base_ref" ]; then
        echo "Error: base branch '$base_branch' not found in local or origin refs."
        exit 1
    fi

    target_path="$(resolve_branch_worktree_path "$repo_name" "$new_branch")"

    if git -C "$bare_dir" show-ref --verify --quiet "refs/heads/$new_branch"; then
        if ! git -C "$bare_dir" worktree add "$target_path" "$new_branch" 2>/dev/null; then
            echo "Branch '$new_branch' may already be checked out in another worktree."
            read -r -p "Force attach with -f? (y/N) " answer
            if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
                git -C "$bare_dir" worktree add -f "$target_path" "$new_branch"
            else
                echo "Aborted."
                exit 1
            fi
        fi
    else
        git -C "$bare_dir" worktree add "$target_path" -b "$new_branch" "$base_ref"
    fi

    prepare_worktree_context "$target_path" "$repo_name"
    LAST_WORKTREE_PATH="$target_path"

    echo "Worktree ready:"
    echo " - Repo: $repo_name"
    echo " - Base: $base_branch"
    echo " - Branch: $new_branch"
    echo " - Path: $target_path"
}

print_repo_status() {
    local repo_name="$1"
    local bare_dir
    bare_dir="$(bare_dir_for_name "$repo_name")"

    echo "- $repo_name"
    git -C "$bare_dir" worktree list --porcelain | awk '
        $1=="worktree"{path=$2}
        $1=="branch"{branch=$2}
        $1=="locked"{locked=$0}
        $1=="prunable"{prunable=$0}
        $0==""{
            line_branch=branch
            if (line_branch == "") { line_branch="(detached)" }
            print "  - " line_branch " (" path ")"
            if (locked != "") print "    " locked
            if (prunable != "") print "    " prunable
            path=branch=locked=prunable=""
        }
    '
}

cmd_status() {
    check_deps git
    ensure_workspace

    local repo_arg="${1:-}"
    local repo_name found=0

    if [ -n "$repo_arg" ]; then
        repo_name="$(repo_name_from_input "$repo_arg")"
        require_initialized_repo "$repo_name"
        print_repo_status "$repo_name"
        return 0
    fi

    echo "Worktree status in $WORKSPACE_DIR:"
    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            found=1
            print_repo_status "$(basename "$repo_dir")"
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "  (none)"
    fi
}

cmd_prune() {
    check_deps git
    ensure_workspace

    local repo_arg="${1:-}"
    local repo_name bare_dir found=0

    if [ -n "$repo_arg" ]; then
        repo_name="$(repo_name_from_input "$repo_arg")"
        require_initialized_repo "$repo_name"
        bare_dir="$(bare_dir_for_name "$repo_name")"
        echo "Pruning worktrees for $repo_name..."
        git -C "$bare_dir" worktree prune -v
        return 0
    fi

    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            found=1
            repo_name="$(basename "$repo_dir")"
            bare_dir="$repo_dir/.bare"
            echo "Pruning worktrees for $repo_name..."
            git -C "$bare_dir" worktree prune -v
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "No initialized repositories found."
    fi
}

cmd_repo() {
    check_deps gh jq fzf
    require_gh_auth
    ensure_workspace

    local owner=""
    local init_after_select="0"
    local arg

    for arg in "$@"; do
        if [ "$arg" = "--init" ]; then
            init_after_select="1"
        elif [ -n "$arg" ]; then
            owner="$arg"
        fi
    done

    if [ -z "$owner" ]; then
        if configured_repo_candidates >/dev/null 2>&1; then
            select_repo_from_config
        else
            owner="$(default_owner)"
            select_repo_from_owner "$owner"
        fi
    else
        select_repo_from_owner "$owner"
    fi

    echo "$REPO_NAME_WITH_OWNER"

    if [ "$init_after_select" = "1" ]; then
        check_deps git
        init_repo
    fi
}

launch_agent() {
    local agent="$1"
    local initial_prompt="${2:-}"

    case "$agent" in
        codex)
            if command -v codex >/dev/null 2>&1; then
                if [ -n "$initial_prompt" ]; then
                    exec codex "$initial_prompt"
                fi
                exec codex
            fi
            echo "Error: 'codex' command not found."
            echo "Install: npm install -g @openai/codex"
            exit 1
            ;;
        gemini)
            if command -v gemini >/dev/null 2>&1; then
                if [ -n "$initial_prompt" ]; then
                    exec gemini "$initial_prompt"
                fi
                exec gemini
            fi
            echo "Error: 'gemini' command not found."
            echo "Install: npm install -g @google/gemini-cli"
            exit 1
            ;;
        claude)
            if command -v claude >/dev/null 2>&1; then
                if [ -n "$initial_prompt" ]; then
                    exec claude "$initial_prompt"
                fi
                exec claude
            fi
            echo "Error: 'claude' command not found."
            echo "Install: npm install -g @anthropic-ai/claude-code"
            exit 1
            ;;
        shell)
            exec "${SHELL:-/bin/zsh}"
            ;;
        *)
            echo "Error: unknown agent '$agent'"
            exit 1
            ;;
    esac
}

select_agent() {
    local agents=("codex" "gemini" "claude" "shell")
    printf "%s\n" "${agents[@]}" | fzf \
        --prompt="Agent> " \
        --height=10 \
        --layout=reverse \
        --header="Choose agent (codex first)"
}

launch_agent_in_worktree() {
    local wt_path="$1"
    local selected="${2:-}"
    local repo_name="${3:-}"
    local initial_prompt

    if [ ! -d "$wt_path" ]; then
        echo "Error: worktree path not found: $wt_path"
        exit 1
    fi

    cd "$wt_path"
    prepare_worktree_context "$wt_path" "$repo_name"
    echo "Switched to worktree: $wt_path"

    if [ -z "$selected" ]; then
        check_deps fzf
        selected="$(select_agent || true)"
    fi

    if [ -z "$selected" ]; then
        echo "No agent selected."
        exit 0
    fi

    initial_prompt="$(build_initial_prompt "$wt_path")"
    launch_agent "$selected" "$initial_prompt"
}

cmd_init() {
    check_deps git gh jq
    require_gh_auth
    ensure_workspace

    local target="${1:-}"

    if [ -z "$target" ]; then
        check_deps fzf
        if configured_repo_candidates >/dev/null 2>&1; then
            select_repo_from_config
        else
            local owner
            owner="$(default_owner)"
            select_repo_from_owner "$owner"
        fi
    elif [[ "$target" == */* ]]; then
        fetch_repo_metadata "$target"
    else
        check_deps fzf
        select_repo_from_owner "$target"
    fi

    init_repo
    cmd_branch "$REPO_NAME"
    launch_agent_in_worktree "$LAST_WORKTREE_PATH" "" "$REPO_NAME"
}

cmd_agent() {
    local selected="${1:-}"
    local wt_path="${2:-}"
    local repo_name=""

    if [ -n "$wt_path" ]; then
        repo_name="$(infer_repo_name_from_worktree "$wt_path" || true)"
        launch_agent_in_worktree "$wt_path" "$selected" "$repo_name"
        return 0
    fi

    if [ -z "$selected" ]; then
        check_deps fzf
        selected="$(select_agent || true)"
    fi

    if [ -z "$selected" ]; then
        echo "No agent selected."
        exit 0
    fi

    launch_agent "$selected"
}

cmd_list() {
    ensure_workspace
    echo "Initialized repositories in $WORKSPACE_DIR:"

    local found=0
    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            found=1
            local repo_name
            repo_name="$(basename "$repo_dir")"
            echo "- $repo_name"
            echo "  bare: $repo_dir/.bare"
            echo "  worktree root: $WORKSPACE_DIR/$repo_name"
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "  (none)"
    fi
}

main() {
    local command="${1:-}"
    case "$command" in
        "")
            print_help
            exit 0
            ;;
        init)
            shift
            cmd_init "${1:-}"
            ;;
        repo)
            shift
            cmd_repo "$@"
            ;;
        branch)
            shift
            cmd_branch "${1:-}" "${2:-}" "${3:-}"
            ;;
        status)
            shift
            cmd_status "${1:-}"
            ;;
        prune)
            shift
            cmd_prune "${1:-}"
            ;;
        agent)
            shift
            cmd_agent "${1:-}" "${2:-}"
            ;;
        list)
            cmd_list
            ;;
        auth-check)
            cmd_auth_check
            ;;
        help|--help|-h)
            print_help
            ;;
        *)
            echo "Unknown command: $command"
            print_help
            exit 1
            ;;
    esac
}

main "$@"
