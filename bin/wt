#!/usr/bin/env bash
set -euo pipefail

WT_ROOT="${WT_ROOT:-$HOME/.wt}"
CONFIG_FILE="$WT_ROOT/config"

if [ -f "$CONFIG_FILE" ]; then
    # shellcheck source=/dev/null
    source "$CONFIG_FILE"
fi

WORKSPACE_DIR="${WORKSPACE_DIR:-$HOME/workspace}"
GITHUB_HOST="${GITHUB_HOST:-github.com}"
GIT_PROTOCOL="${GIT_PROTOCOL:-ssh}"
DEFAULT_AGENT="${DEFAULT_AGENT:-codex}"
DEFAULT_GITHUB_OWNER="${DEFAULT_GITHUB_OWNER:-}"
REPOSITORY_LIST="${REPOSITORY_LIST:-}"
WT_TEMPLATE_DIR="${WT_TEMPLATE_DIR:-$WT_ROOT/templates}"
LAST_WORKTREE_PATH=""

print_help() {
    cat <<'HELP'
wt - Worktree automation CLI (macOS + GitHub)

Usage:
  wt init [owner/repo|owner]
  wt repo [owner] [--init]
  wt branch [repo|owner/repo] [new-branch] [base-branch]
  wt status [repo] [--json]
  wt prune [repo]
  wt pr [worktree-path]
  wt agent [codex|gemini|claude|shell] [worktree-path]
  wt list [--json]
  wt auth-check
  wt help

Notes:
  - Agent order starts with codex by design.
  - `wt init` continues to branch creation and agent launch.
  - Worktrees are created under: <workspace>/<repo>/<branch>
HELP
}

check_deps() {
    local deps=("$@")
    local dep
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            echo "Error: '$dep' is required."
            exit 1
        fi
    done
}

ensure_workspace() {
    mkdir -p "$WORKSPACE_DIR"
}

repo_name_from_input() {
    local input="$1"
    if [[ "$input" == */* ]]; then
        echo "${input##*/}"
        return 0
    fi
    echo "$input"
}

bare_dir_for_name() {
    local repo_name="$1"
    echo "$WORKSPACE_DIR/$repo_name/.bare"
}

worktree_root_for_name() {
    local repo_name="$1"
    echo "$WORKSPACE_DIR/$repo_name"
}

require_initialized_repo() {
    local repo_name="$1"
    local bare_dir
    bare_dir="$(bare_dir_for_name "$repo_name")"
    if [ ! -d "$bare_dir" ]; then
        echo "Error: Repository '$repo_name' is not initialized."
        echo "Run: wt init <owner/repo>"
        exit 1
    fi
}

list_initialized_repo_names() {
    ensure_workspace
    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            basename "$repo_dir"
        fi
    done
}

pick_initialized_repo() {
    local selected
    selected="$(list_initialized_repo_names | fzf --prompt="Repo> " --height=30% --layout=reverse || true)"
    if [ -z "$selected" ]; then
        echo "No repository selected."
        exit 0
    fi
    echo "$selected"
}

require_gh_auth() {
    if gh auth status -h "$GITHUB_HOST" >/dev/null 2>&1; then
        return 0
    fi
    echo "GitHub auth is not configured for host: $GITHUB_HOST"
    echo "Run: gh auth login -h $GITHUB_HOST"
    exit 1
}

default_owner() {
    if [ -n "$DEFAULT_GITHUB_OWNER" ]; then
        echo "$DEFAULT_GITHUB_OWNER"
        return 0
    fi

    local owner
    owner="$(gh api user --jq '.login' 2>/dev/null || true)"
    if [ -n "$owner" ]; then
        echo "$owner"
        return 0
    fi

    echo "Error: Could not detect default GitHub owner." >&2
    echo "Set DEFAULT_GITHUB_OWNER in $CONFIG_FILE or pass owner explicitly." >&2
    exit 1
}

configured_repo_candidates() {
    if [ -z "$REPOSITORY_LIST" ]; then
        return 1
    fi

    local parsed
    parsed="$({
        echo "$REPOSITORY_LIST" | tr ',;' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//'
    } | awk 'NF && $0 ~ /.+\/.+/ && !seen[$0]++')"

    if [ -z "$parsed" ]; then
        return 1
    fi
    echo "$parsed"
}

cmd_auth_check() {
    if gh auth status -h "$GITHUB_HOST" >/dev/null 2>&1; then
        echo "GitHub auth is ready for host: $GITHUB_HOST"
        return 0
    fi

    echo "GitHub auth is not configured for host: $GITHUB_HOST"
    echo "Run: gh auth login -h $GITHUB_HOST"
    return 1
}

fetch_repo_metadata_json() {
    local repo_full="$1"
    gh repo view "$repo_full" --json nameWithOwner,sshUrl,url,isPrivate 2>/dev/null || true
}

set_repo_metadata_from_json() {
    local repo_json="$1"
    REPO_NAME_WITH_OWNER="$(echo "$repo_json" | jq -r '.nameWithOwner')"
    REPO_NAME="$(echo "$repo_json" | jq -r '.nameWithOwner | split("/") | .[1]')"
    REPO_SSH_URL="$(echo "$repo_json" | jq -r '.sshUrl')"
    REPO_HTTP_URL="$(echo "$repo_json" | jq -r '.url')"
    REPO_VISIBILITY="$(echo "$repo_json" | jq -r 'if .isPrivate then "private" else "public" end')"
}

fetch_repo_metadata() {
    local repo_full="$1"
    local repo_json
    repo_json="$(fetch_repo_metadata_json "$repo_full")"
    if [ -z "$repo_json" ] || [ "$repo_json" = "null" ]; then
        echo "Error: Repository not found or access denied: $repo_full"
        exit 1
    fi
    set_repo_metadata_from_json "$repo_json"
}

set_repo_metadata_from_tsv_row() {
    local repo_row="$1"
    REPO_NAME_WITH_OWNER="$(echo "$repo_row" | awk -F'\t' '{print $1}')"
    REPO_NAME="${REPO_NAME_WITH_OWNER##*/}"
    REPO_SSH_URL="$(echo "$repo_row" | awk -F'\t' '{print $2}')"
    REPO_HTTP_URL="$(echo "$repo_row" | awk -F'\t' '{print $3}')"
    if [ "$(echo "$repo_row" | awk -F'\t' '{print $4}')" = "true" ]; then
        REPO_VISIBILITY="private"
    else
        REPO_VISIBILITY="public"
    fi
}

select_repo_from_project_file() {
    local project_file="$1"
    local display_file selected_line selected_repo repo_row
    display_file="$(mktemp)"

    while IFS=$'\t' read -r name_with_owner _ssh _https is_private; do
        local repo_name state vis
        repo_name="${name_with_owner##*/}"
        vis="public"
        if [ "$is_private" = "true" ]; then
            vis="private"
        fi

        if [ -d "$WORKSPACE_DIR/$repo_name/.bare" ]; then
            state="[Initialized]"
        else
            state="[New]"
        fi

        echo "$state $name_with_owner ($vis)" >> "$display_file"
    done < "$project_file"

    selected_line="$(fzf --prompt="Repo> " --height=40% --layout=reverse < "$display_file" || true)"
    rm -f "$display_file"

    if [ -z "$selected_line" ]; then
        echo "No repository selected."
        exit 0
    fi

    selected_repo="$(echo "$selected_line" | awk '{print $2}')"
    repo_row="$(awk -F'\t' -v repo="$selected_repo" '$1 == repo { print; exit }' "$project_file")"

    if [ -z "$repo_row" ]; then
        echo "Error: Failed to resolve repository metadata for selection."
        exit 1
    fi

    set_repo_metadata_from_tsv_row "$repo_row"
}

select_repo_from_owner() {
    local owner="$1"
    local repos_json project_file

    repos_json="$(gh repo list "$owner" --limit 200 --json nameWithOwner,sshUrl,url,isPrivate 2>/dev/null || true)"
    if [ -z "$repos_json" ] || [ "$repos_json" = "[]" ]; then
        echo "Error: No repositories found for owner '$owner' or access denied."
        exit 1
    fi

    project_file="$(mktemp)"
    echo "$repos_json" | jq -r '.[] | "\(.nameWithOwner)\t\(.sshUrl)\t\(.url)\t\(.isPrivate)"' > "$project_file"
    select_repo_from_project_file "$project_file"
    rm -f "$project_file"
}

select_repo_from_config() {
    local project_file repo_candidate repo_json
    project_file="$(mktemp)"

    while IFS= read -r repo_candidate; do
        repo_json="$(fetch_repo_metadata_json "$repo_candidate")"
        if [ -z "$repo_json" ] || [ "$repo_json" = "null" ]; then
            echo "Warning: configured repository not accessible: $repo_candidate"
            continue
        fi
        echo "$repo_json" | jq -r '"\(.nameWithOwner)\t\(.sshUrl)\t\(.url)\t\(.isPrivate)"' >> "$project_file"
    done < <(configured_repo_candidates || true)

    if [ ! -s "$project_file" ]; then
        rm -f "$project_file"
        echo "Error: No accessible repositories found in REPOSITORY_LIST."
        echo "Set REPOSITORY_LIST in $CONFIG_FILE as comma-separated owner/repo values."
        exit 1
    fi

    select_repo_from_project_file "$project_file"
    rm -f "$project_file"
}

repo_clone_url() {
    if [ "$GIT_PROTOCOL" = "ssh" ]; then
        echo "$REPO_SSH_URL"
        return 0
    fi
    echo "$REPO_HTTP_URL"
}

init_repo() {
    local repo_dir bare_dir clone_url
    repo_dir="$WORKSPACE_DIR/$REPO_NAME"
    bare_dir="$repo_dir/.bare"

    if [ -d "$bare_dir" ]; then
        echo "Already initialized: $REPO_NAME_WITH_OWNER"
        echo " - Bare repo: $bare_dir"
        echo " - Worktree location: $repo_dir/<branch>"
        return 0
    fi

    if [ -d "$repo_dir/.git" ]; then
        echo "Error: Standard repo exists at $repo_dir"
        echo "Phase 3 convert support is not included yet. Move/rename it first."
        exit 1
    fi

    if [ -e "$repo_dir" ] && [ ! -d "$repo_dir" ]; then
        echo "Error: Path exists and is not a directory: $repo_dir"
        exit 1
    fi

    clone_url="$(repo_clone_url)"
    mkdir -p "$repo_dir"
    git clone --bare "$clone_url" "$bare_dir"
    git -C "$bare_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"

    echo "Initialized repository:"
    echo " - Repo: $REPO_NAME_WITH_OWNER ($REPO_VISIBILITY)"
    echo " - Bare repo: $bare_dir"
    echo " - Worktree location: $repo_dir/<branch>"
}

normalize_branch_name() {
    local branch_name="$1"
    echo "${branch_name#origin/}"
}

list_branch_candidates() {
    local bare_dir="$1"
    {
        git -C "$bare_dir" for-each-ref --format='%(refname:short)' refs/heads
        git -C "$bare_dir" for-each-ref --format='%(refname:short)' refs/remotes/origin | sed '/^origin\/HEAD$/d;s#^origin/##'
    } | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | awk 'NF && $0 != "origin" && !seen[$0]++' | sort -u
}

branch_exists_in_bare() {
    local bare_dir="$1"
    local branch_name="$2"
    git -C "$bare_dir" show-ref --verify --quiet "refs/heads/$branch_name" \
        || git -C "$bare_dir" show-ref --verify --quiet "refs/remotes/origin/$branch_name"
}

create_non_main_base_branch() {
    local bare_dir="$1"
    local new_base=""
    local seed_ref=""

    echo "No non-main base branch is available." >&2
    echo "Main branch is excluded from worktree base and PR target policy." >&2
    echo "Create a PR base branch first (examples: develop, integration/core)." >&2
    read -r -p "New base branch name: " new_base
    new_base="$(normalize_branch_name "$new_base")"

    if [ -z "$new_base" ] || [ "$new_base" = "main" ]; then
        echo "Error: base branch name must be non-empty and cannot be 'main'." >&2
        exit 1
    fi

    if branch_exists_in_bare "$bare_dir" "$new_base"; then
        echo "Base branch '$new_base' already exists. Using it." >&2
        echo "$new_base"
        return 0
    fi

    if git -C "$bare_dir" show-ref --verify --quiet "refs/remotes/origin/main"; then
        seed_ref="origin/main"
    elif git -C "$bare_dir" show-ref --verify --quiet "refs/heads/main"; then
        seed_ref="main"
    else
        echo "Error: Could not find seed ref for new base branch (expected main or origin/main)." >&2
        exit 1
    fi

    git -C "$bare_dir" branch "$new_base" "$seed_ref" >/dev/null
    git -C "$bare_dir" push origin "refs/heads/$new_base:refs/heads/$new_base" >/dev/null

    echo "Created base branch '$new_base' from '$seed_ref'." >&2
    echo "$new_base"
}

choose_base_branch() {
    local bare_dir="$1"
    local selected all_candidates non_main_candidates
    all_candidates="$(list_branch_candidates "$bare_dir" || true)"
    non_main_candidates="$(echo "$all_candidates" | awk '$0 != "main"')"

    if [ -z "$non_main_candidates" ]; then
        if echo "$all_candidates" | awk '$0 == "main" { found=1 } END { exit !found }'; then
            selected="$(create_non_main_base_branch "$bare_dir")"
            echo "$selected"
            return 0
        fi
        echo "Error: no base branches available."
        exit 1
    fi

    selected="$(echo "$non_main_candidates" | fzf --prompt="Base> " --height=30% --layout=reverse || true)"
    if [ -z "$selected" ]; then
        echo "No base branch selected."
        exit 1
    fi
    echo "$selected"
}

resolve_base_ref() {
    local bare_dir="$1"
    local base_branch="$2"
    base_branch="$(normalize_branch_name "$base_branch")"
    if [ "$base_branch" = "origin" ]; then
        return 1
    fi
    if [ "$base_branch" = "main" ]; then
        return 1
    fi
    if git -C "$bare_dir" show-ref --verify --quiet "refs/heads/$base_branch"; then
        echo "$base_branch"
        return 0
    fi
    if git -C "$bare_dir" show-ref --verify --quiet "refs/remotes/origin/$base_branch"; then
        echo "origin/$base_branch"
        return 0
    fi
    return 1
}

resolve_branch_worktree_path() {
    local repo_name="$1"
    local branch_name="$2"
    local root path suffix dir_name
    root="$(worktree_root_for_name "$repo_name")"
    mkdir -p "$root"

    # Convert unsafe path characters to '-', then normalize dashes.
    # Keep only alnum, dot, underscore, dash.
    dir_name="$(echo "$branch_name" \
        | sed 's/[^[:alnum:]._-]/-/g' \
        | sed 's/-\\{2,\\}/-/g' \
        | sed 's/^-*//;s/-*$//')"
    if [ -z "$dir_name" ]; then
        dir_name="branch"
    fi

    path="$root/$dir_name"
    if [ ! -e "$path" ]; then
        echo "$path"
        return 0
    fi
    suffix="$(date +%s)"
    echo "${path}_${suffix}"
}

seed_worktree_file() {
    local worktree_path="$1"
    local file_name="$2"
    local src="$WT_TEMPLATE_DIR/$file_name"
    local dst="$worktree_path/$file_name"
    if [ -f "$src" ] && [ ! -f "$dst" ]; then
        cp "$src" "$dst"
    fi
}

set_repo_toml_project_name() {
    local repo_toml="$1"
    local repo_name="$2"
    local tmp_file

    if [ ! -f "$repo_toml" ] || [ -z "$repo_name" ]; then
        return 0
    fi

    tmp_file="$(mktemp)"
    awk -v repo="$repo_name" '
        BEGIN { name_replaced = 0 }
        {
            gsub(/__REPO_NAME__/, repo)
            if (!name_replaced && $0 ~ /^name[[:space:]]*=/) {
                print "name = \"" repo "\""
                name_replaced = 1
                next
            }
            print
        }
    ' "$repo_toml" > "$tmp_file"
    mv "$tmp_file" "$repo_toml"
}

infer_repo_name_from_worktree() {
    local worktree_path="$1"
    local wt_abs ws_abs rel

    if [ ! -d "$worktree_path" ]; then
        return 1
    fi

    wt_abs="$(cd "$worktree_path" && pwd -P)"
    ws_abs="$(cd "$WORKSPACE_DIR" && pwd -P 2>/dev/null || true)"

    if [ -z "$ws_abs" ]; then
        return 1
    fi

    case "$wt_abs" in
        "$ws_abs"/*)
            rel="${wt_abs#$ws_abs/}"
            echo "${rel%%/*}"
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

prepare_worktree_context() {
    local worktree_path="$1"
    local repo_name="${2:-}"

    mkdir -p "$worktree_path"
    seed_worktree_file "$worktree_path" "repo.toml"
    seed_worktree_file "$worktree_path" "mcp-usage-guidelines.md"

    if [ -z "$repo_name" ]; then
        repo_name="$(infer_repo_name_from_worktree "$worktree_path" || true)"
    fi

    set_repo_toml_project_name "$worktree_path/repo.toml" "$repo_name"
}

worktree_metadata_file() {
    local worktree_path="$1"
    echo "$worktree_path/.wt/metadata"
}

read_worktree_metadata_value() {
    local worktree_path="$1"
    local key="$2"
    local metadata_file
    metadata_file="$(worktree_metadata_file "$worktree_path")"
    if [ ! -f "$metadata_file" ]; then
        return 1
    fi
    awk -F'=' -v k="$key" '$1 == k { print substr($0, index($0, "=") + 1); exit }' "$metadata_file"
}

write_worktree_metadata_value() {
    local worktree_path="$1"
    local key="$2"
    local value="$3"
    local metadata_dir metadata_file tmp_file
    metadata_dir="$worktree_path/.wt"
    metadata_file="$(worktree_metadata_file "$worktree_path")"
    mkdir -p "$metadata_dir"

    if [ -f "$metadata_file" ] && grep -q "^${key}=" "$metadata_file"; then
        tmp_file="$(mktemp)"
        awk -F'=' -v k="$key" -v v="$value" '
            $1 == k { print k "=" v; updated=1; next }
            { print }
            END { if (!updated) print k "=" v }
        ' "$metadata_file" > "$tmp_file"
        mv "$tmp_file" "$metadata_file"
        return 0
    fi

    printf "%s=%s\n" "$key" "$value" >> "$metadata_file"
}

set_source_base_for_branch() {
    local worktree_path="$1"
    local branch_name="$2"
    local source_base="$3"
    local existing_source_base
    source_base="$(normalize_branch_name "$source_base")"

    if [ -z "$source_base" ]; then
        return 1
    fi

    existing_source_base="$(read_worktree_metadata_value "$worktree_path" "source_base_branch" || true)"
    existing_source_base="$(normalize_branch_name "${existing_source_base:-}")"
    if [ -n "$existing_source_base" ]; then
        if [ "$existing_source_base" != "$source_base" ]; then
            echo "Warning: source_base_branch is immutable. Keeping existing '$existing_source_base' (requested '$source_base')." >&2
        fi
        source_base="$existing_source_base"
    fi

    git -C "$worktree_path" config "branch.$branch_name.wt-source-base" "$source_base"
    git -C "$worktree_path" config "branch.$branch_name.gh-merge-base" "$source_base"
    write_worktree_metadata_value "$worktree_path" "source_base_branch" "$source_base"
}

resolve_source_base_branch() {
    local worktree_path="$1"
    local branch_name="$2"
    local source_base

    source_base="$(read_worktree_metadata_value "$worktree_path" "source_base_branch" || true)"
    if [ -n "$source_base" ]; then
        echo "$(normalize_branch_name "$source_base")"
        return 0
    fi

    source_base="$(git -C "$worktree_path" config --get "branch.$branch_name.wt-source-base" || true)"
    if [ -n "$source_base" ]; then
        source_base="$(normalize_branch_name "$source_base")"
        write_worktree_metadata_value "$worktree_path" "source_base_branch" "$source_base"
        echo "$source_base"
        return 0
    fi

    source_base="$(git -C "$worktree_path" config --get "branch.$branch_name.gh-merge-base" || true)"
    if [ -n "$source_base" ]; then
        source_base="$(normalize_branch_name "$source_base")"
        write_worktree_metadata_value "$worktree_path" "source_base_branch" "$source_base"
        echo "$source_base"
        return 0
    fi

    return 1
}

current_branch_name() {
    local worktree_path="$1"
    git -C "$worktree_path" symbolic-ref --short HEAD 2>/dev/null || true
}

build_initial_prompt() {
    local worktree_path="$1"

    cat <<PROMPT
Project bootstrap context:
1) Read ./repo.toml for repository-specific defaults.
2) Read ./mcp-usage-guidelines.md and follow those MCP usage rules.
3) Then continue work in this branch worktree: $worktree_path
PROMPT
}

cmd_branch() {
    check_deps git
    ensure_workspace

    local repo_arg="${1:-}"
    local new_branch="${2:-}"
    local base_branch="${3:-}"
    local repo_name bare_dir target_path base_ref

    if [ -z "$repo_arg" ] || [ -z "$base_branch" ]; then
        check_deps fzf
    fi

    if [ -z "$repo_arg" ]; then
        repo_name="$(pick_initialized_repo)"
    else
        repo_name="$(repo_name_from_input "$repo_arg")"
    fi

    require_initialized_repo "$repo_name"
    bare_dir="$(bare_dir_for_name "$repo_name")"

    git -C "$bare_dir" fetch --all --prune >/dev/null 2>&1 || true

    if [ -z "$base_branch" ]; then
        base_branch="$(choose_base_branch "$bare_dir")"
    fi
    base_branch="$(normalize_branch_name "$base_branch")"
    if [ "$base_branch" = "main" ]; then
        echo "Error: base branch 'main' is not allowed for worktree creation."
        echo "Choose or create a non-main base branch."
        if ! echo "$(list_branch_candidates "$bare_dir" || true)" | awk '$0 != "main" { found=1 } END { exit !found }'; then
            create_non_main_base_branch "$bare_dir" >/dev/null
        fi
        exit 1
    fi

    if [ -z "$new_branch" ]; then
        read -r -p "New branch name: " new_branch
    fi
    if [ -z "$new_branch" ]; then
        echo "Error: new branch name is required."
        exit 1
    fi

    base_ref="$(resolve_base_ref "$bare_dir" "$base_branch" || true)"
    if [ -z "$base_ref" ]; then
        echo "Error: base branch '$base_branch' not found in local or origin refs."
        exit 1
    fi

    target_path="$(resolve_branch_worktree_path "$repo_name" "$new_branch")"

    if git -C "$bare_dir" show-ref --verify --quiet "refs/heads/$new_branch"; then
        if ! git -C "$bare_dir" worktree add "$target_path" "$new_branch" 2>/dev/null; then
            echo "Branch '$new_branch' may already be checked out in another worktree."
            read -r -p "Force attach with -f? (y/N) " answer
            if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
                git -C "$bare_dir" worktree add -f "$target_path" "$new_branch"
            else
                echo "Aborted."
                exit 1
            fi
        fi
    else
        git -C "$bare_dir" worktree add "$target_path" -b "$new_branch" "$base_ref"
    fi

    prepare_worktree_context "$target_path" "$repo_name"
    set_source_base_for_branch "$target_path" "$new_branch" "$base_branch" >/dev/null 2>&1 || true
    LAST_WORKTREE_PATH="$target_path"

    echo "Worktree ready:"
    echo " - Repo: $repo_name"
    echo " - Base: $base_branch"
    echo " - Branch: $new_branch"
    echo " - Path: $target_path"
}

print_repo_status() {
    local repo_name="$1"
    local bare_dir
    local path="" branch="" locked="" prunable="" is_bare="0"
    bare_dir="$(bare_dir_for_name "$repo_name")"

    echo "- $repo_name"
    while IFS= read -r line || [ -n "$line" ]; do
        if [ -z "$line" ]; then
            if [ -n "$path" ] && [ "$is_bare" != "1" ]; then
                local line_branch short_branch source_base
                line_branch="$branch"
                if [ -z "$line_branch" ]; then
                    line_branch="(detached)"
                fi
                short_branch="${line_branch#refs/heads/}"
                echo "  - $line_branch ($path)"
                if [ -d "$path" ] && [ "$short_branch" != "(detached)" ]; then
                    source_base="$(resolve_source_base_branch "$path" "$short_branch" || true)"
                    if [ -n "$source_base" ]; then
                        echo "    source_base_branch: $source_base"
                    fi
                fi
                if [ -n "$locked" ]; then
                    echo "    $locked"
                fi
                if [ -n "$prunable" ]; then
                    echo "    $prunable"
                fi
            fi
            path=""; branch=""; locked=""; prunable=""; is_bare="0"
            continue
        fi
        case "$line" in
            worktree\ *)
                path="${line#worktree }"
                ;;
            branch\ *)
                branch="${line#branch }"
                ;;
            bare)
                is_bare="1"
                ;;
            locked*)
                locked="$line"
                ;;
            prunable*)
                prunable="$line"
                ;;
        esac
    done < <(git -C "$bare_dir" worktree list --porcelain; echo)
}

repo_status_json() {
    local repo_name="$1"
    local bare_dir
    local path="" branch="" locked="" prunable="" is_bare="0"
    local records_file

    bare_dir="$(bare_dir_for_name "$repo_name")"
    records_file="$(mktemp)"

    while IFS= read -r line || [ -n "$line" ]; do
        if [ -z "$line" ]; then
            if [ -n "$path" ] && [ "$is_bare" != "1" ]; then
                local line_branch short_branch source_base
                line_branch="$branch"
                if [ -z "$line_branch" ]; then
                    line_branch="(detached)"
                fi
                short_branch="${line_branch#refs/heads/}"
                source_base=""
                if [ -d "$path" ] && [ "$short_branch" != "(detached)" ]; then
                    source_base="$(resolve_source_base_branch "$path" "$short_branch" || true)"
                fi
                jq -cn \
                    --arg path "$path" \
                    --arg branch "$short_branch" \
                    --arg source_base_branch "$source_base" \
                    --arg locked "$locked" \
                    --arg prunable "$prunable" \
                    '{
                        path: $path,
                        branch: $branch,
                        source_base_branch: (if $source_base_branch == "" then null else $source_base_branch end),
                        locked: (if $locked == "" then null else $locked end),
                        prunable: (if $prunable == "" then null else $prunable end)
                    }' >> "$records_file"
            fi
            path=""; branch=""; locked=""; prunable=""; is_bare="0"
            continue
        fi
        case "$line" in
            worktree\ *) path="${line#worktree }" ;;
            branch\ *) branch="${line#branch }" ;;
            bare) is_bare="1" ;;
            locked*) locked="$line" ;;
            prunable*) prunable="$line" ;;
        esac
    done < <(git -C "$bare_dir" worktree list --porcelain; echo)

    jq -cn \
        --arg repo "$repo_name" \
        --slurpfile worktrees "$records_file" \
        '{ repo: $repo, worktrees: $worktrees }'
    rm -f "$records_file"
}

cmd_status() {
    check_deps git
    ensure_workspace

    local repo_arg=""
    local output_json="0"
    local arg repo_name found=0

    for arg in "$@"; do
        case "$arg" in
            --json)
                output_json="1"
                ;;
            -*)
                echo "Error: unsupported option '$arg' for wt status."
                exit 1
                ;;
            *)
                if [ -n "$repo_arg" ]; then
                    echo "Error: too many arguments for wt status."
                    exit 1
                fi
                repo_arg="$arg"
                ;;
        esac
    done

    if [ "$output_json" = "1" ]; then
        check_deps jq
        local repo_json_file
        repo_json_file="$(mktemp)"
        if [ -n "$repo_arg" ]; then
            repo_name="$(repo_name_from_input "$repo_arg")"
            require_initialized_repo "$repo_name"
            repo_status_json "$repo_name" > "$repo_json_file"
        else
            local repo_dir
            for repo_dir in "$WORKSPACE_DIR"/*; do
                if [ -d "$repo_dir/.bare" ]; then
                    repo_status_json "$(basename "$repo_dir")" >> "$repo_json_file"
                fi
            done
        fi

        jq -cn \
            --arg workspace "$WORKSPACE_DIR" \
            --slurpfile repositories "$repo_json_file" \
            '{ workspace: $workspace, repositories: $repositories }'
        rm -f "$repo_json_file"
        return 0
    fi

    if [ -n "$repo_arg" ]; then
        repo_name="$(repo_name_from_input "$repo_arg")"
        require_initialized_repo "$repo_name"
        print_repo_status "$repo_name"
        return 0
    fi

    echo "Worktree status in $WORKSPACE_DIR:"
    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            found=1
            print_repo_status "$(basename "$repo_dir")"
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "  (none)"
    fi
}

cmd_prune() {
    check_deps git
    ensure_workspace

    local repo_arg="${1:-}"
    local repo_name bare_dir found=0

    if [ -n "$repo_arg" ]; then
        repo_name="$(repo_name_from_input "$repo_arg")"
        require_initialized_repo "$repo_name"
        bare_dir="$(bare_dir_for_name "$repo_name")"
        echo "Pruning worktrees for $repo_name..."
        git -C "$bare_dir" worktree prune -v
        return 0
    fi

    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            found=1
            repo_name="$(basename "$repo_dir")"
            bare_dir="$repo_dir/.bare"
            echo "Pruning worktrees for $repo_name..."
            git -C "$bare_dir" worktree prune -v
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "No initialized repositories found."
    fi
}

resolve_pr_worktree_path() {
    local input_path="${1:-}"
    local wt_path=""
    if [ -n "$input_path" ]; then
        wt_path="$input_path"
    else
        wt_path="$(git rev-parse --show-toplevel 2>/dev/null || true)"
    fi
    if [ -z "$wt_path" ] || [ ! -d "$wt_path" ]; then
        echo "Error: worktree path not found. Pass it explicitly: wt pr /abs/path/to/worktree" >&2
        exit 1
    fi
    echo "$wt_path"
}

ensure_clean_worktree_for_rebase() {
    local wt_path="$1"
    if ! git -C "$wt_path" diff --quiet || ! git -C "$wt_path" diff --cached --quiet; then
        echo "Error: working tree has uncommitted changes."
        echo "Commit or stash changes before running 'wt pr'."
        exit 1
    fi
}

print_rebase_conflict_help() {
    local wt_path="$1"
    local conflicted
    conflicted="$(git -C "$wt_path" diff --name-only --diff-filter=U || true)"
    echo "Rebase conflict detected. PR creation stopped."
    if [ -n "$conflicted" ]; then
        echo "Conflicted files:"
        echo "$conflicted" | sed 's/^/ - /'
    fi
    echo "Resolve conflicts, then run:"
    echo "  git -C \"$wt_path\" add <files>"
    echo "  git -C \"$wt_path\" rebase --continue"
    echo "If you need to rollback:"
    echo "  git -C \"$wt_path\" rebase --abort"
    echo "After resolving, re-run: wt pr \"$wt_path\""
}

repo_slug_from_remote_url() {
    local remote_url="$1"
    local host="$GITHUB_HOST"
    remote_url="${remote_url#git@${host}:}"
    remote_url="${remote_url#https://${host}/}"
    remote_url="${remote_url#ssh://git@${host}/}"
    remote_url="${remote_url%.git}"
    echo "$remote_url"
}

cmd_pr() {
    local input_path=""
    local wt_path branch_name source_base_branch repo_name
    local head_branch
    local arg

    for arg in "$@"; do
        case "$arg" in
            --base|-B)
                echo "Error: --base is not allowed. Base branch is enforced from source_base_branch metadata."
                exit 1
                ;;
            --head|-H)
                echo "Error: --head is not allowed. Head branch is always current worktree branch."
                exit 1
                ;;
            -*)
                echo "Error: unsupported option '$arg' for wt pr."
                exit 1
                ;;
            *)
                if [ -n "$input_path" ]; then
                    echo "Error: too many arguments for wt pr."
                    exit 1
                fi
                input_path="$arg"
                ;;
        esac
    done

    check_deps git gh
    require_gh_auth

    wt_path="$(resolve_pr_worktree_path "$input_path")"
    branch_name="$(current_branch_name "$wt_path")"
    if [ -z "$branch_name" ]; then
        echo "Error: could not determine current branch (detached HEAD or invalid worktree)."
        exit 1
    fi
    if [ "$branch_name" = "main" ]; then
        echo "Error: main branch is excluded from 'wt pr'."
        exit 1
    fi

    source_base_branch="$(resolve_source_base_branch "$wt_path" "$branch_name" || true)"
    if [ -z "$source_base_branch" ]; then
        echo "Error: source_base_branch metadata not found for this worktree."
        echo "Recreate the worktree branch with 'wt branch' to register base metadata."
        exit 1
    fi
    if [ "$source_base_branch" = "main" ]; then
        echo "Error: PR target branch 'main' is blocked by policy."
        echo "Use a non-main integration branch as source base."
        exit 1
    fi

    repo_name="$(infer_repo_name_from_worktree "$wt_path" || true)"
    if [ -n "$repo_name" ]; then
        require_initialized_repo "$repo_name"
    fi

    ensure_clean_worktree_for_rebase "$wt_path"

    echo "Pre-PR gate: fetch + rebase onto origin/$source_base_branch"
    git -C "$wt_path" fetch origin --prune
    if ! git -C "$wt_path" show-ref --verify --quiet "refs/remotes/origin/$source_base_branch"; then
        echo "Error: origin/$source_base_branch not found."
        exit 1
    fi

    if ! git -C "$wt_path" rebase "origin/$source_base_branch"; then
        print_rebase_conflict_help "$wt_path"
        exit 1
    fi

    head_branch="$branch_name"
    echo "Creating PR with enforced base policy:"
    echo " - base: $source_base_branch"
    echo " - head: $head_branch"
    git -C "$wt_path" push -u origin "$head_branch"
    gh -R "$(repo_slug_from_remote_url "$(git -C "$wt_path" config --get remote.origin.url)")" \
        pr create --base "$source_base_branch" --head "$head_branch"
}

cmd_repo() {
    check_deps gh jq fzf
    require_gh_auth
    ensure_workspace

    local owner=""
    local init_after_select="0"
    local arg

    for arg in "$@"; do
        if [ "$arg" = "--init" ]; then
            init_after_select="1"
        elif [ -n "$arg" ]; then
            owner="$arg"
        fi
    done

    if [ -z "$owner" ]; then
        if configured_repo_candidates >/dev/null 2>&1; then
            select_repo_from_config
        else
            owner="$(default_owner)"
            select_repo_from_owner "$owner"
        fi
    else
        select_repo_from_owner "$owner"
    fi

    echo "$REPO_NAME_WITH_OWNER"

    if [ "$init_after_select" = "1" ]; then
        check_deps git
        init_repo
    fi
}

launch_agent() {
    local agent="$1"
    local initial_prompt="${2:-}"

    case "$agent" in
        codex)
            if command -v codex >/dev/null 2>&1; then
                if [ -n "$initial_prompt" ]; then
                    exec codex "$initial_prompt"
                fi
                exec codex
            fi
            echo "Error: 'codex' command not found."
            echo "Install: npm install -g @openai/codex"
            exit 1
            ;;
        gemini)
            if command -v gemini >/dev/null 2>&1; then
                if [ -n "$initial_prompt" ]; then
                    exec gemini "$initial_prompt"
                fi
                exec gemini
            fi
            echo "Error: 'gemini' command not found."
            echo "Install: npm install -g @google/gemini-cli"
            exit 1
            ;;
        claude)
            if command -v claude >/dev/null 2>&1; then
                if [ -n "$initial_prompt" ]; then
                    exec claude "$initial_prompt"
                fi
                exec claude
            fi
            echo "Error: 'claude' command not found."
            echo "Install: npm install -g @anthropic-ai/claude-code"
            exit 1
            ;;
        shell)
            exec "${SHELL:-/bin/zsh}"
            ;;
        *)
            echo "Error: unknown agent '$agent'"
            exit 1
            ;;
    esac
}

select_agent() {
    local agents=("codex" "gemini" "claude" "shell")
    printf "%s\n" "${agents[@]}" | fzf \
        --prompt="Agent> " \
        --height=10 \
        --layout=reverse \
        --header="Choose agent (codex first)"
}

launch_agent_in_worktree() {
    local wt_path="$1"
    local selected="${2:-}"
    local repo_name="${3:-}"
    local initial_prompt

    if [ ! -d "$wt_path" ]; then
        echo "Error: worktree path not found: $wt_path"
        exit 1
    fi

    cd "$wt_path"
    prepare_worktree_context "$wt_path" "$repo_name"
    echo "Switched to worktree: $wt_path"

    if [ -z "$selected" ]; then
        check_deps fzf
        selected="$(select_agent || true)"
    fi

    if [ -z "$selected" ]; then
        echo "No agent selected."
        exit 0
    fi

    initial_prompt="$(build_initial_prompt "$wt_path")"
    launch_agent "$selected" "$initial_prompt"
}

cmd_init() {
    check_deps git gh jq
    require_gh_auth
    ensure_workspace

    local target="${1:-}"

    if [ -z "$target" ]; then
        check_deps fzf
        if configured_repo_candidates >/dev/null 2>&1; then
            select_repo_from_config
        else
            local owner
            owner="$(default_owner)"
            select_repo_from_owner "$owner"
        fi
    elif [[ "$target" == */* ]]; then
        fetch_repo_metadata "$target"
    else
        check_deps fzf
        select_repo_from_owner "$target"
    fi

    init_repo
    cmd_branch "$REPO_NAME"
    launch_agent_in_worktree "$LAST_WORKTREE_PATH" "" "$REPO_NAME"
}

cmd_agent() {
    local selected="${1:-}"
    local wt_path="${2:-}"
    local repo_name=""

    if [ -n "$wt_path" ]; then
        repo_name="$(infer_repo_name_from_worktree "$wt_path" || true)"
        launch_agent_in_worktree "$wt_path" "$selected" "$repo_name"
        return 0
    fi

    if [ -z "$selected" ]; then
        check_deps fzf
        selected="$(select_agent || true)"
    fi

    if [ -z "$selected" ]; then
        echo "No agent selected."
        exit 0
    fi

    launch_agent "$selected"
}

cmd_list() {
    ensure_workspace

    local output_json="0"
    local arg
    for arg in "$@"; do
        case "$arg" in
            --json)
                output_json="1"
                ;;
            -*)
                echo "Error: unsupported option '$arg' for wt list."
                exit 1
                ;;
            *)
                echo "Error: wt list does not accept positional arguments."
                exit 1
                ;;
        esac
    done

    if [ "$output_json" = "1" ]; then
        cmd_status --json
        return 0
    fi

    echo "Initialized repositories in $WORKSPACE_DIR:"

    local found=0
    local repo_dir
    for repo_dir in "$WORKSPACE_DIR"/*; do
        if [ -d "$repo_dir/.bare" ]; then
            found=1
            local repo_name
            local status_json
            repo_name="$(basename "$repo_dir")"
            echo "- $repo_name"
            echo "  bare: $repo_dir/.bare"
            echo "  worktree root: $WORKSPACE_DIR/$repo_name"
            status_json="$(repo_status_json "$repo_name")"
            echo "$status_json" | jq -r '
                if (.worktrees | length) == 0 then
                    "  worktrees: (none)"
                else
                    "  worktrees:" ,
                    (.worktrees[] | "    - \(.branch) (\(.path)) source_base=\(.source_base_branch // "null")")
                end
            '
        fi
    done

    if [ "$found" -eq 0 ]; then
        echo "  (none)"
    fi
}

main() {
    local command="${1:-}"
    case "$command" in
        "")
            print_help
            exit 0
            ;;
        init)
            shift
            cmd_init "${1:-}"
            ;;
        repo)
            shift
            cmd_repo "$@"
            ;;
        branch)
            shift
            cmd_branch "${1:-}" "${2:-}" "${3:-}"
            ;;
        status)
            shift
            cmd_status "$@"
            ;;
        prune)
            shift
            cmd_prune "${1:-}"
            ;;
        pr)
            shift
            cmd_pr "$@"
            ;;
        agent)
            shift
            cmd_agent "${1:-}" "${2:-}"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        auth-check)
            cmd_auth_check
            ;;
        help|--help|-h)
            print_help
            ;;
        *)
            echo "Unknown command: $command"
            print_help
            exit 1
            ;;
    esac
}

main "$@"
